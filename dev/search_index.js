var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = TemporaryArrays","category":"page"},{"location":"#TemporaryArrays","page":"Home","title":"TemporaryArrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TemporaryArrays.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [TemporaryArrays]","category":"page"},{"location":"#TemporaryArrays.@temparray-Tuple{Any, Any, Vararg{Any}}","page":"Home","title":"TemporaryArrays.@temparray","text":"@temparray(F, shape, index...)\n\nAllocate an array, for temporary use in a local scope.\n\nSubsequent calls with the same signature     (e.g. from the same line of code repeated in a loop)     will be allocated the same array, without any extra allocations.\n\nThe point is to be able to use \"work variables\"     that persist and get re-used throughout a computation,     but in a julianic and readable way.\n\nOf course, if that array is still being used by the previous call, chaos ensues. This macro will automatically insert an additional index unique to the calling module     to prevent unintended collisions. Nevertheless, you should be careful to always use a different index     when requesting multiple arrays of the same type and shape     from within the same module. Most importantly, do not EVER let the arrays escape their local scope,     i.e. never return them in a function call.\n\nParameters\n\nF::Type{<:Number} - a concrete number type (e.g. Float64)\nshape::Tuple{Int} - the shape of the array\nindex::Any - a unique identifier, to prevent unwanted collisions\n@doctest```   a1 = @temparray(Float64, (3,4), :same)   a2 = @temparray(Float64, (3,4), :same)   a3 = @temparray(Float64, (3,4), :different)\n@assert eltype(a1) == Float64   @assert shape(a1) == (3,4)   @assert a1 === a2   @assert a1 !== a3   ```\n\n\n\n\n\n","category":"macro"}]
}
